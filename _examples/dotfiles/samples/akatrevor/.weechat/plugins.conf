#
# weechat -- plugins.conf
#
# WARNING: It is NOT recommended to edit this file by hand,
# especially if WeeChat is running.
#
# Use /set or similar command to change settings in WeeChat.
#
# For more info, see: https://weechat.org/doc/quickstart
#

[var]
fifo.fifo = "on"
guile.check_license = "off"
javascript.check_license = "off"
lua.check_license = "off"
lua.emoji.incoming = "on"
lua.matrix.autojoin_on_invite = "on"
lua.matrix.backlog_lines = "120"
lua.matrix.debug = "off"
lua.matrix.encrypted_message_color = "lightgreen"
lua.matrix.homeserver_url = "https://matrix.org/"
lua.matrix.local_echo = "on"
lua.matrix.password = ""
lua.matrix.presence_filter = "off"
lua.matrix.typing_notices = "on"
lua.matrix.user = ""
perl.atcomplete.enabled = "on"
perl.awaylog.command = ""
perl.awaylog.name_color = "default"
perl.awaylog.notify = "on"
perl.awaylog.on_away_only = "off"
perl.awaylog.plugin_color = "default"
perl.beep.beep_command_dcc = "$bell"
perl.beep.beep_command_highlight = "$bell"
perl.beep.beep_command_pv = "$bell"
perl.beep.beep_command_timeout = "30000"
perl.beep.beep_dcc = "on"
perl.beep.beep_highlight = "on"
perl.beep.beep_highlight_blacklist = "off"
perl.beep.beep_highlight_whitelist = "off"
perl.beep.beep_pv = "on"
perl.beep.beep_pv_blacklist = "off"
perl.beep.beep_pv_whitelist = "off"
perl.beep.beep_trigger_highlight = ""
perl.beep.beep_trigger_pv = ""
perl.beep.bell_always = ""
perl.beep.blacklist_nicks = ""
perl.beep.whitelist_channels = ""
perl.beep.whitelist_nicks = ""
perl.chanmon.alignment = "channel"
perl.chanmon.color_buf = "on"
perl.chanmon.disqus.#data-feed = "off"
perl.chanmon.disqus.#nerds = "off"
perl.chanmon.disqus.#ops = "on"
perl.chanmon.dynamic = "on"
perl.chanmon.first_run = "true"
perl.chanmon.freenode.#ubuntu = "off"
perl.chanmon.logging = "off"
perl.chanmon.merge_private = "on"
perl.chanmon.nick_prefix = "@"
perl.chanmon.nick_suffix = ":"
perl.chanmon.output = "buffer"
perl.chanmon.short_names = "on"
perl.chanmon.show_aways = "off"
perl.check_license = "off"
perl.commorkers.ignore_all_triggered_notices = "off"
perl.commorkers.ignore_nicks = ""
perl.commorkers.ignore_nicks_triggered_notices = ""
perl.highmon.alignment = "channel"
perl.highmon.away_only = "off"
perl.highmon.color_buf = "on"
perl.highmon.first_run = "true"
perl.highmon.hotlist_show = "on"
perl.highmon.logging = "off"
perl.highmon.merge_private = "on"
perl.highmon.nick_prefix = "<"
perl.highmon.nick_suffix = ">"
perl.highmon.output = "buffer"
perl.highmon.short_names = "on"
perl.stalker.additional_join_info = "off"
perl.stalker.db_name = "%h/nicks.db"
perl.stalker.debug = "off"
perl.stalker.flood_max_nicks = "20"
perl.stalker.flood_timer = "10"
perl.stalker.guest_host_regex = "^webchat"
perl.stalker.guest_nick_regex = "^(guest|weebot|Floodbot|ChanServ).*"
perl.stalker.ignore_guest_hosts = "off"
perl.stalker.ignore_guest_nicks = "on"
perl.stalker.ignore_nickchange = "off"
perl.stalker.ignore_whois = "off"
perl.stalker.max_recursion = "20"
perl.stalker.normalize_nicks = "on"
perl.stalker.recursive_search = "on"
perl.stalker.search_this_network_only = "on"
perl.stalker.tags = ""
perl.stalker.timeout = "1"
perl.stalker.use_localvar = "off"
python.apply_corrections.check_every = "5"
python.apply_corrections.data_timeout = "60"
python.apply_corrections.message_limit = "2"
python.apply_corrections.print_format = "[nick]: [corrected]"
python.apply_corrections.print_limit = "1"
python.autojoin.autosave = "off"
python.autojoin_on_invite.autojoin_key = "on"
python.autojoin_on_invite.ignore_channels = ""
python.autojoin_on_invite.ignore_nicks = ""
python.autojoin_on_invite.whitelist_channels = ""
python.autojoin_on_invite.whitelist_nicks = ""
python.autojoinem.sorted = "off"
python.automarkbuffer.clear = "all"
python.automarkbuffer.ignore_hidden = "on"
python.automarkbuffer.ignore_query = "on"
python.automarkbuffer.interval = "60"
python.automarkbuffer.time = "3600"
python.automarkbuffer.whitelist = ""
python.autosavekey.add = "off"
python.autosavekey.mute = "off"
python.autosavekey.secure = "off"
python.buffer_autoclose.age_limit = "86400"
python.buffer_autoclose.ignore = ""
python.buffer_autoclose.interval = "1"
python.bufsize.count_filtered_lines = "on"
python.bufsize.format = "${color:yellow}%P${color:default}⋅%{${color:yellow}%A${color:default}⇵${color:yellow}%C${color:default}/}${color:yellow}%L"
python.bufsize.show_scroll = "on"
python.chanact.color_1 = "white"
python.chanact.color_2 = "cyan"
python.chanact.color_3 = "lightcyan"
python.chanact.color_4 = "yellow"
python.chanact.color_8 = "cyan"
python.chanact.color_default = "default"
python.chanact.delimiter = ","
python.chanact.item_length = "8"
python.chanact.lowest_priority = "0"
python.chanact.message = "Act: "
python.chanact.skip_number_binds = "on"
python.chanact.sort_by_number = "off"
python.chanact.use_keybindings = "on"
python.chancomp.compare_only_on_command = "off"
python.chancomp.ignored_servers = ""
python.chancomp.output_priority = "shared"
python.chancomp.sorting = "none"
python.chancomp.verbose_output = "on"
python.chanpriority.whitelist = ""
python.chanstat.average_period = "30"
python.chanstat.path = "%h/chanstat"
python.chanstat.show_lows = "on"
python.chanstat.show_peaks = "on"
python.check_license = "off"
python.go.auto_jump = "off"
python.go.buffer_number = "off"
python.go.color_name = "black,cyan"
python.go.color_name_highlight = "red,cyan"
python.go.color_name_highlight_selected = "red,brown"
python.go.color_name_selected = "black,brown"
python.go.color_number = "yellow,magenta"
python.go.color_number_selected = "yellow,red"
python.go.fuzzy_search = "on"
python.go.message = "Go: "
python.go.short_name = "on"
python.go.sort = "number,beginning"
python.go.use_core_instead_weechat = "off"
python.grep.clear_buffer = "off"
python.grep.default_tail_head = "10"
python.grep.go_to_buffer = "on"
python.grep.log_filter = ""
python.grep.max_lines = "4000"
python.grep.show_summary = "on"
python.grep.size_limit = "2048"
python.grep_filter.bar_item = "grep"
python.grep_filter.enable = "off"
python.lastfm.command = "/me is listening to %s"
python.lastfm.lastfm_username = "yourusername"
python.lnotify.highlight = "on"
python.lnotify.icon = "weechat"
python.lnotify.notify_away = "off"
python.lnotify.query = "on"
python.maskmatch.blacklist = ""
python.maskmatch.disabled = "false"
python.maskmatch.ignore_masks = "*!*@*"
python.maskmatch.limit = "4"
python.maskmatch.match_set = "true"
python.maskmatch.match_unset = "true"
python.maskmatch.matching_modes = "bIqe"
python.maskmatch.prefix = "_script_name_"
python.maskmatch.prefix_color = "green"
python.maskmatch.print_as_list = "false"
python.maskmatch.sorting = "alpha_ignore_case"
python.maskmatch.verbose = "false"
python.maskmatch.whitelist = ""
python.postpone.match_prefix = ""
python.postpone.message_on_nick = "off"
python.screen_away.away_suffix = ""
python.screen_away.command_on_attach = ""
python.screen_away.command_on_detach = ""
python.screen_away.ignore = ""
python.screen_away.ignore_relays = "off"
python.screen_away.interval = "5"
python.screen_away.message = "Detached from screen"
python.screen_away.set_away = "on"
python.screen_away.time_format = "since %Y-%m-%d %H:%M:%S%z"
python.slack.background_load_all_history = "true"
python.slack.cache_messages = "true"
python.slack.channel_name_typing_indicator = "true"
python.slack.colorize_messages = "1"
python.slack.colorize_nicks = "1"
python.slack.colorize_private_chats = "1"
python.slack.debug_level = "3"
python.slack.debug_mode = "false"
python.slack.distracting_channels = "#nerds,#fun,#notfun"
python.slack.map_underline_to = "_"
python.slack.migrated = "true"
python.slack.never_away = "true"
python.slack.record_events = "false"
python.slack.render_bold_as = "bold"
python.slack.render_italic_as = "italic"
python.slack.server_aliases = "disqus:d,trevorj:tj,neoturbine:neo,usvnetwork:usv"
python.slack.short_buffer_names = "true"
python.slack.show_reaction_nicks = "1"
python.slack.slack_api_token = "${sec.data.trevorj_slack_token},${sec.data.docman_slack_token},${sec.data.disqus_slack_token},${sec.data.usv_slack_token},${sec.data.suqsid_slack_token}"
python.slack.slack_timeout = "20000"
python.slack.switch_buffer_on_join = "1"
python.slack.thread_suffix_color = "lightcyan"
python.slack.trigger_value = "0"
python.slack.unfurl_ignore_alt_text = "0"
python.slack.unhide_buffers_with_activity = "true"
python.slack_extension.colorize_messages = "1"
python.slack_extension.colorize_nicks = "1"
python.slack_extension.colorize_private_chats = "1"
python.slack_extension.debug_mode = "false"
python.slack_extension.distracting_channels = "#nerds,#fun,#notfun"
python.slack_extension.show_reaction_nicks = "1"
python.slack_extension.slack_api_token = "${sec.data.trevorj_slack_token},${sec.data.docman_slack_token},${sec.data.disqus_slack_token}"
python.slack_extension.slack_timeout = "20000"
python.slack_extension.switch_buffer_on_join = "1"
python.slack_extension.trigger_value = "0"
python.slack_extension.unfurl_ignore_alt_text = "1"
python.spotify.buffers = "freenode.#mychan,"
python.spotify.emit_notice = "off"
python.title.current_buffer_prefix = ""
python.title.current_buffer_suffix = ""
python.title.hotlist_buffer_prefix = ""
python.title.hotlist_buffer_suffix = ""
python.title.hotlist_number_prefix = ""
python.title.hotlist_number_suffix = ""
python.title.hotlist_separator = ":"
python.title.short_name = "on"
python.title.show_hotlist = "on"
python.title.title_prefix = "[WeeChat ${info:version}] "
python.title.title_priority = "2"
python.title.title_suffix = ""
python.url_olde.ignored_channels = "chanmon"
python.urlbuf.display_active_buffer = "on"
python.urlbuf.display_buffer_number = "on"
python.urlbuf.display_nick = "off"
python.urlbuf.display_private = "on"
python.urlbuf.skip_buffers = ""
python.urlbuf.skip_duplicates = "on"
python.urlserver.buffer_short_name = "off"
python.urlserver.color = "darkgray"
python.urlserver.color_in_msg = ""
python.urlserver.debug = "off"
python.urlserver.display_urls = "on"
python.urlserver.display_urls_in_msg = "off"
python.urlserver.http_allowed_ips = ""
python.urlserver.http_auth = ""
python.urlserver.http_auth_redirect = "on"
python.urlserver.http_autostart = "on"
python.urlserver.http_bg_color = "#f4f4f4"
python.urlserver.http_css_url = ""
python.urlserver.http_embed_image = "off"
python.urlserver.http_embed_youtube = "off"
python.urlserver.http_embed_youtube_size = "480*350"
python.urlserver.http_fg_color = "#000"
python.urlserver.http_hostname = ""
python.urlserver.http_hostname_display = ""
python.urlserver.http_open_in_new_page = "on"
python.urlserver.http_port = ""
python.urlserver.http_port_display = ""
python.urlserver.http_prefix_suffix = " "
python.urlserver.http_scheme_display = "http"
python.urlserver.http_time_format = "%d/%m/%y %H:%M:%S"
python.urlserver.http_title = "WeeChat URLs"
python.urlserver.http_url_prefix = ""
python.urlserver.msg_filtered = "off"
python.urlserver.msg_ignore_buffers = "core.weechat,python.grep"
python.urlserver.msg_ignore_dup_urls = "off"
python.urlserver.msg_ignore_regex = ""
python.urlserver.msg_ignore_tags = "irc_quit,irc_part,notify_none"
python.urlserver.msg_require_tags = "nick_"
python.urlserver.separators = "[|]"
python.urlserver.url_min_length = "0"
python.urlserver.urls_amount = "100"
python.vimode.no_warn = "off"
python.weemustfeed.feeds = ""
python.weemustfeed.interval = "300"
python.weetweet.alt_rt_style = "off"
python.weetweet.auth_complete = "off"
python.weetweet.home_replies = "off"
python.weetweet.last_id = ""
python.weetweet.oauth_secret = ""
python.weetweet.oauth_token = ""
python.weetweet.print_id = "on"
python.weetweet.screen_name = ""
python.weetweet.tweet_nicks = "on"
python.whowas_timeago.show_errors = "false"
ruby.check_license = "off"
tcl.check_license = "off"

[desc]
lua.emoji.incoming = "Also try to replace shortcodes to emoji in incoming messages (default: "on")"
lua.matrix.autojoin_on_invite = "Automatically join rooms you are invited to (default: "on")"
lua.matrix.backlog_lines = "Number of lines to fetch from backlog upon connecting (default: "120")"
lua.matrix.debug = "Print a lot of extra information to help with finding bugs and other problems. (default: "off")"
lua.matrix.encrypted_message_color = "Print encrypted mesages with this color (default: "lightgreen")"
lua.matrix.homeserver_url = "Full URL including port to your homeserver (including trailing slash) or use default matrix.org (default: "https://matrix.org/")"
lua.matrix.local_echo = "Print lines locally instead of waiting for return from server (default: "on")"
lua.matrix.password = "Your homeserver password (default: "")"
lua.matrix.presence_filter = "Filter presence messages and ephemeral events (for performance) (default: "off")"
lua.matrix.typing_notices = "Send typing notices when you type (default: "on")"
lua.matrix.user = "Your homeserver username (default: "")"
perl.atcomplete.enabled = "enable completion of nicks starting with @ (default: "on")"
perl.beep.beep_command_dcc = "command for beep on dcc, special value "$bell" is allowed, as well as "$bell;command" (default: "$bell")"
perl.beep.beep_command_highlight = "command for beep on highlight, special value "$bell" is allowed, as well as "$bell;command" (default: "$bell")"
perl.beep.beep_command_pv = "command for beep on private message, special value "$bell" is allowed, as well as "$bell;command" (default: "$bell")"
perl.beep.beep_command_timeout = "timeout for command run (in milliseconds, 0 = never kill (not recommended)) (default: "30000")"
perl.beep.beep_dcc = "beep on dcc (default: "on")"
perl.beep.beep_highlight = "beep on highlight (default: "on")"
perl.beep.beep_highlight_blacklist = "turn blacklist for highlights on or off (default: "off")"
perl.beep.beep_highlight_whitelist = "turn whitelist for highlights on or off (default: "off")"
perl.beep.beep_pv = "beep on private message (default: "on")"
perl.beep.beep_pv_blacklist = "turn blacklist for private messages on or off (default: "off")"
perl.beep.beep_pv_whitelist = "turn whitelist for private messages on or off (default: "off")"
perl.beep.beep_trigger_highlight = "word that will trigger execution of beep_command_highlight (if empty, anything will trigger) (default: "")"
perl.beep.beep_trigger_pv = "word that will trigger execution of beep_command_pv (it empty, anything will trigger) (default: "")"
perl.beep.bell_always = "use $bell on private messages and/or highlights regardless of trigger and whitelist settings (example: "pv,highlight") (default: "")"
perl.beep.blacklist_nicks = "comma-separated list of "server.nick": if not empty, these nicks will not be able to trigger execution of commands. Cannot be used in conjuction with whitelist (example: "freenode.nick1,freenode.nick2") (default: "")"
perl.beep.whitelist_channels = "comma-separated list of "server.#channel": if not empty, only these channels will trigger execution of commands (example: "freenode.#weechat,freenode.#channel2") (default: "")"
perl.beep.whitelist_nicks = "comma-separated list of "server.nick": if not empty, only these nicks will trigger execution of commands (example: "freenode.nick1,freenode.nick2") (default: "")"
perl.stalker.additional_join_info = "add a line below the JOIN message that will display alternative nicks (tags: "irc_join", "irc_smart_filter" will be add to additional_join_info). You can use a localvar to drop additional join info for specific buffer(s) "stalker_drop_additional_join_info" (default: off)"
perl.stalker.db_name = "file containing the SQLite database where information is recorded. This database is created on loading of stalker if it does not exist. ("%h" will be replaced by WeeChat home, "~/.weechat" by default) (default: %h/nicks.db)"
perl.stalker.debug = "Prints debug output to core buffer so you know exactly what is going on. This is far too verbose to be enabled when not actively debugging something. (default: off)"
perl.stalker.flood_max_nicks = "Maximum number of joins to allow in flood_timer length of time. Once maximum number of joins is reached, joins will be ignored until the timer ends (default:20)"
perl.stalker.flood_timer = "Time in seconds for which flood protection is active. Once max_nicks is reached, joins will be ignored for the remaining duration of the timer. (default:10)"
perl.stalker.guest_host_regex = "regex mask to ignore host masks"
perl.stalker.guest_nick_regex = "Some networks set default nicknames when a user fails to identify to nickserv, other networks using relay-bots, some irc clients set default nicknames when someone connects and often these change from network to network depending on who is configuring the java irc clients. This allows a regular expression to be entered. When a nickname matches the regular expression and "ignore_guest_nicks" is enabled the nickname is dropped from the search as if it had never been seen. (default: ^(guest|weebot|Floodbot).*)"
perl.stalker.ignore_guest_hosts = "See option guest_host_regex"
perl.stalker.ignore_guest_nicks = "See option guest_nick_regex"
perl.stalker.ignore_nickchange = "When enabled, /NICK changes won't be monitored. (default: off)"
perl.stalker.ignore_whois = "When enabled, /WHOIS won't be monitored. (default: off)"
perl.stalker.max_recursion = "For each correlation between nick <-> host that happens, one point of recursion happens. A corrupt database, general evilness, or misfortune can cause the recursion to skyrocket. This is a ceiling number that says if after this many correlation attempts we have not found all nickname and hostname correlations, stop the process and return the list to this point. Use this option with care on slower machines like raspberry pi."
perl.stalker.normalize_nicks = "this option will truncate special chars from username (like: ~) (default: on)"
perl.stalker.recursive_search = "When enabled, recursive search causes stalker to function better than a simple hostname to nickname map. Disabling the recursive search in effect turns stalker into a more standard hostname -> nickname map."
perl.stalker.search_this_network_only = "When enabled searches are limited to within the network the window is currently set on. Turning this off is really only useful if multiple networks don't encode the hostmask. (default: on)"
perl.stalker.tags = "comma separated list of tags used for messages printed by stalker. See documentation for possible tags (e.g. 'no_log', 'no_highlight'). This option does not effect DEBUG messages."
perl.stalker.timeout = "timeout in seconds for hook_process(), used with option "additional_join_info". On slower machines, like raspberry pi, increase time. (default: 1)"
perl.stalker.use_localvar = "When enabled, only channels with a localvar 'stalker' will be monitored. This option will not affect /NICK and /WHOIS monitoring. It's only for /JOIN messages. (default: off)"
python.apply_corrections.check_every = "Interval between each check for expired messages."
python.apply_corrections.data_timeout = "Time before a message is expired."
python.apply_corrections.message_limit = "Number of messages to store per nick."
python.apply_corrections.print_format = "Format string for the printed corrections."
python.apply_corrections.print_limit = "Maximum number of lines to correct."
python.autojoinem.sorted = "channels will be sorted in autojoin-option. if autojoin-option contains channel-keys, this option will be ignored. (default: "off")"
python.automarkbuffer.clear = "hotlist = remove buffer from hotlist, unread = set unread marker, all = hotlist & unread (default: 'all')"
python.automarkbuffer.ignore_hidden = "hidden messages will be ignored (for example "irc_smart_filter" ones) (default: 'on')"
python.automarkbuffer.ignore_query = "query buffer(s) will be ignored (default: 'on')"
python.automarkbuffer.interval = "how often in seconds to check for messages (default: '60')"
python.automarkbuffer.time = "time in seconds to mark buffer as read, if there are no new messages (default: '3600')"
python.automarkbuffer.whitelist = "comma separated list of buffer to ignore, e.g. freenode.#weechat,freenode.#weechat-de (check name of buffer with : /buffer localvar) (default: '')"
python.autosavekey.add = "adds channel and key to autojoin list on /join, if channel/key does not already exists (default: "off")"
python.autosavekey.mute = "execute command silently, only error messages will be displayed. (default: "off")"
python.autosavekey.secure = "change channel key in secure data. (default: "off")"
python.bufsize.count_filtered_lines = "filtered lines will be count in item. (default: 'on')"
python.bufsize.format = "format for items to display in bar, possible items: %P = percent indicator, %A = number of lines below last line, %L = lines counter, %C = current line %F = number of filtered lines (note: using WeeChat >= 0.4.2, content is evaluated, so you can use colors with format "${color:xxx}", see /help eval) (default: '${color:yellow}%P${color:default}⋅%{${color:yellow}%A${color:default}⇵${color:yellow}%C${color:default}/}${color:yellow}%L')"
python.bufsize.show_scroll = "always show the scroll indicator number,even if its 0 (item %A), if option is off the scroll indicator will be hidden like the item "scroll" (default: 'on')"
python.chancomp.compare_only_on_command = "Specifically require chancomp for comparisons?"
python.chancomp.ignored_servers = "Servers to ignore comparisons with, comma separated."
python.chancomp.output_priority = "How to display output? smart, shared, not_shared"
python.chancomp.sorting = "Ensure sorting shared channel WHOIS output? none, alpha, alpha_ignore_case"
python.chancomp.verbose_output = "Also show output when all or none channels are shared"
python.go.auto_jump = "automatically jump to buffer when it is uniquely selected (default: "off")"
python.go.buffer_number = "display buffer number (default: "on")"
python.go.color_name = "color for buffer name (not selected) (default: "black,cyan")"
python.go.color_name_highlight = "color for highlight in buffer name (not selected) (default: "red,cyan")"
python.go.color_name_highlight_selected = "color for highlight in a selected buffer name (default: "red,brown")"
python.go.color_name_selected = "color for a selected buffer name (default: "black,brown")"
python.go.color_number = "color for buffer number (not selected) (default: "yellow,magenta")"
python.go.color_number_selected = "color for selected buffer number (default: "yellow,red")"
python.go.fuzzy_search = "search buffer matches using approximation (default: "off")"
python.go.message = "message to display before list of buffers (default: "Go to: ")"
python.go.short_name = "display and search in short names instead of buffer name (default: "off")"
python.go.sort = "comma-separated list of keys to sort buffers (the order is important, sorts are performed in the given order): name = sort by name (or short name),  (default: "number,beginning")"
python.go.use_core_instead_weechat = "use name "core" instead of "weechat" for core buffer (default: "off")"
python.grep_filter.bar_item = "text to show in bar item when filtering (default: "grep")"
python.grep_filter.enable = "enable automatically start filtering when searching (default: "off")"
python.maskmatch.blacklist = "List of servers, channels, or server.channel combinations this should not be done for (whitelist takes precedence). Comma separated string"
python.maskmatch.disabled = "Set this to true to entirely disable mode matching, and just allow use for the /maskmatch command. Boolean"
python.maskmatch.ignore_masks = "Hostmasks that are too broad that should be ignored. Comma separated string"
python.maskmatch.limit = "How many matches should be displayed at maximum? Number"
python.maskmatch.match_set = "Match when a mode gets set. Boolean"
python.maskmatch.match_unset = "Match when a mode gets unset. Boolean"
python.maskmatch.matching_modes = "List of mode characters to match on, every character represents a mode."
python.maskmatch.prefix = "The name the script will have. Special options: _script_name_, _prefix_network_, _setter_, _target_"
python.maskmatch.prefix_color = "The colour the prefix will have. If prefix is wrapped in brackets, the brackets will have this color. Any weechat-supported color"
python.maskmatch.print_as_list = "Print as one large list, less information - but can fit more names at cost of readability. Boolean"
python.maskmatch.sorting = "Sort names alphabetically or not. none, alpha, or alpha_ignore_case"
python.maskmatch.verbose = "Print also if no matches are found. Boolean"
python.maskmatch.whitelist = "List of servers, channels, or server.channel combinations this should be done for. Comma separated string"
python.postpone.match_prefix = "Postpone message if prefix before "nick:" is matched. (Default: "")"
python.postpone.message_on_nick = "Send message on /nick in addition to /join (Default: off)"
python.screen_away.away_suffix = "What to append to your nick when you're away."
python.screen_away.command_on_attach = "Commands to execute on attach, separated by semicolon"
python.screen_away.command_on_detach = "Commands to execute on detach, separated by semicolon"
python.screen_away.ignore = "Comma-separated list of servers to ignore."
python.screen_away.ignore_relays = "Only check screen status and ignore relay interfaces"
python.screen_away.interval = "How often in seconds to check screen status"
python.screen_away.message = "Away message"
python.screen_away.set_away = "Set user as away."
python.screen_away.time_format = "time format append to away message"
python.slack.background_load_all_history = "Load history for each channel in the background as soon as it opens, rather than waiting for the user to look at it."
python.slack.channel_name_typing_indicator = "Change the prefix of a channel from # to > when someone is typing in it. Note that this will (temporarily) affect the sort order if you sort buffers by name rather than by number."
python.slack.colorize_private_chats = "Whether to use nick-colors in DM windows."
python.slack.debug_level = "Show only this level of debug info (or higher) when debug_mode is on. Lower levels -> more messages."
python.slack.debug_mode = "Open a dedicated buffer for debug messages and start logging to it. How verbose the logging is depends on log_level."
python.slack.distracting_channels = "List of channels to hide."
python.slack.map_underline_to = "When sending underlined text to slack, use this formatting character for it. The default ("_") sends it as italics. Use "*" to send bold instead."
python.slack.never_away = "Poke Slack every five minutes so that it never marks you "away"."
python.slack.record_events = "Log all traffic from Slack to disk as JSON."
python.slack.render_bold_as = "When receiving bold text from Slack, render it as this in weechat."
python.slack.render_italic_as = "When receiving bold text from Slack, render it as this in weechat. If your terminal lacks italic support, consider using "underline" instead."
python.slack.server_aliases = "A comma separated list of `subdomain:alias` pairs. The alias will be used instead of the actual name of the slack (in buffer names, logging, etc). E.g `work:no_fun_allowed` would make your work slack show up as `no_fun_allowed` rather than `work.slack.com`."
python.slack.short_buffer_names = "Use `foo.#channel` rather than `foo.slack.com.#channel` as the internal name for Slack buffers. Overrides server_aliases."
python.slack.show_reaction_nicks = "Display the name of the reacting user(s) alongside each reactji."
python.slack.slack_api_token = "List of Slack API tokens, one per Slack instance you want to connect to. See the README for details on how to get these."
python.slack.slack_timeout = "How long (ms) to wait when communicating with Slack."
python.slack.switch_buffer_on_join = "When /joining a channel, automatically switch to it as well."
python.slack.thread_suffix_color = "Color to use for the [thread: XXX] suffix on messages that have threads attached to them."
python.slack.unfurl_ignore_alt_text = "When displaying ("unfurling") links to channels/users/etc, ignore the "alt text" present in the message and instead use the canonical name of the thing being linked to."
python.slack.unhide_buffers_with_activity = "When activity occurs on a buffer, unhide it even if it was previously hidden (whether by the user or by the distracting_channels setting)."
python.spotify.buffers = "A comma separated list of buffers the script should check"
python.spotify.emit_notice = "If on, this script will use /notice, if off, it will use /msg to post info"
python.url_olde.ignored_channels = "comma separated list of buffers you want ignored. eg. freenode.#channelname"
python.urlbuf.display_active_buffer = "display URLs from the active buffer"
python.urlbuf.display_buffer_number = "display the buffer's number"
python.urlbuf.display_nick = "display the nick of the user"
python.urlbuf.display_private = "display URLs from private messages"
python.urlbuf.skip_buffers = "a comma separated list of buffer numbers to skip"
python.urlbuf.skip_duplicates = "skip the URL that is already in the urlbuf"
python.urlserver.buffer_short_name = "use buffer short name on dedicated buffer (default: "off")"
python.urlserver.color = "color for urls displayed after message (default: "darkgray")"
python.urlserver.color_in_msg = "color for urls displayed inside irc message: it is a number (irc color) between 00 and 15 (see doc for a list of irc colors) (default: "")"
python.urlserver.debug = "print some debug messages (default: "off")"
python.urlserver.display_urls = "display URLs below messages (default: "on")"
python.urlserver.display_urls_in_msg = "add shorten url next to the original url (only in IRC messages) (useful for urlserver behind relay/irc) (default: "off")"
python.urlserver.http_allowed_ips = "regex for IPs allowed to use server (example: "^(123.45.67.89|192.160.*)$") (default: "")"
python.urlserver.http_auth = "login and password (format: "login:password") required to access to page with list of URLs (note: content is evaluated, see /help eval) (default: "")"
python.urlserver.http_auth_redirect = "require the login/password (if option "http_auth" is set) for URLs redirections (default: "on")"
python.urlserver.http_autostart = "start the built-in HTTP server automatically) (default: "on")"
python.urlserver.http_bg_color = "background color for HTML page (default: "#f4f4f4")"
python.urlserver.http_css_url = "URL of external Cascading Style Sheet to add (BE CAREFUL: the HTTP referer will be sent to site hosting CSS file!) (empty value = use default embedded CSS) (default: "")"
python.urlserver.http_embed_image = "embed images in HTML page (BE CAREFUL: the HTTP referer will be sent to site hosting image!) (default: "off")"
python.urlserver.http_embed_youtube = "embed youtube videos in HTML page (BE CAREFUL: the HTTP referer will be sent to youtube!) (default: "off")"
python.urlserver.http_embed_youtube_size = "size for embedded youtube video, format is "xxx*yyy" (default: "480*350")"
python.urlserver.http_fg_color = "foreground color for HTML page (default: "#000")"
python.urlserver.http_hostname = "force hostname/IP in bind of socket (empty value = auto-detect current hostname) (default: "")"
python.urlserver.http_hostname_display = "display this hostname in shortened URLs (default: "")"
python.urlserver.http_open_in_new_page = "open links in new pages/tabs (default: "on")"
python.urlserver.http_port = "force port for listening (empty value = find a random free port) (default: "")"
python.urlserver.http_port_display = "display this port in shortened URLs. Useful if you forward a different external port to the internal port (default: "")"
python.urlserver.http_prefix_suffix = "suffix displayed between prefix and message in HTML page (default: " ")"
python.urlserver.http_scheme_display = "display this scheme in shortened URLs (default: "http")"
python.urlserver.http_time_format = "time format in the HTML page (default: "%d/%m/%y %H:%M:%S")"
python.urlserver.http_title = "title of the HTML page (default: "WeeChat URLs")"
python.urlserver.http_url_prefix = "prefix to add in URLs to prevent external people to scan your URLs (for example: prefix "xx" will give URL: http://host.com:1234/xx/8) (default: "")"
python.urlserver.msg_filtered = "shorten URLs in filtered messages (with /filter) (default: "off")"
python.urlserver.msg_ignore_buffers = "comma-separated list (without spaces) of buffers to ignore (full name like "irc.freenode.#weechat") (default: "core.weechat,python.grep")"
python.urlserver.msg_ignore_dup_urls = "ignore duplicated URLs (do not add an URL in list if it is already) (default: "off")"
python.urlserver.msg_ignore_regex = "ignore messages matching this regex (default: "")"
python.urlserver.msg_ignore_tags = "comma-separated list (without spaces) of tags (or beginning of tags) to ignore (for example, use "notify_none" to ignore self messages or "nick_weebot" to ignore messages from nick "weebot") (default: "irc_quit,irc_part,notify_none")"
python.urlserver.msg_require_tags = "comma-separated list (without spaces) of tags (or beginning of tags) required to shorten URLs (for example "nick_" to shorten URLs only in messages from other users) (default: "nick_")"
python.urlserver.separators = "separators for short url list (string with exactly 3 chars) (default: "[|]")"
python.urlserver.url_min_length = "minimum length for an URL to be shortened (0 = shorten all URLs, -1 = detect length based on shorten URL) (default: "0")"
python.urlserver.urls_amount = "number of URLs to keep in memory (and in file when script is not loaded) (default: "100")"
python.vimode.no_warn = "don't warn about problematickeybindings and tmux/screen (default: "off")"
python.whowas_timeago.show_errors = "Display error messages when timestamp cannot be parsed. true or false"
